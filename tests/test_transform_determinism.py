"""Property-based tests for transform determinism.

This module tests that transforms produce consistent, deterministic results.
A transform is deterministic if applying it multiple times to the same input
produces equivalent outputs.

This is a critical property for reproducibility and debugging.
"""

import polars as pl
from hypothesis import given, settings

from fintran.core.schema import validate_ir

from .conftest import valid_ir_dataframe


class IdentityTransform:
    """A simple transform that returns a copy of the input DataFrame."""

    def transform(self, df: pl.DataFrame) -> pl.DataFrame:
        """Return a copy of the input DataFrame.

        Args:
            df: Input IR DataFrame

        Returns:
            A copy of the input DataFrame
        """
        return df.clone()


class SortTransform:
    """A transform that sorts by date and account.

    This is deterministic - same input always produces same output.
    """

    def transform(self, df: pl.DataFrame) -> pl.DataFrame:
        """Sort the DataFrame by date and account.

        Args:
            df: Input IR DataFrame

        Returns:
            Sorted DataFrame
        """
        if len(df) == 0:
            return df.clone()
        return df.sort(["date", "account"])


class AddDescriptionTransform:
    """A transform that adds a default description to null descriptions.

    This is deterministic - same input always produces same output.
    """

    def transform(self, df: pl.DataFrame) -> pl.DataFrame:
        """Add default description where null.

        Args:
            df: Input IR DataFrame

        Returns:
            DataFrame with default descriptions filled in
        """
        if len(df) == 0:
            return df.clone()

        return df.with_columns(
            pl.when(pl.col("description").is_null())
            .then(pl.lit("No description"))
            .otherwise(pl.col("description"))
            .alias("description")
        )


# Feature: core-infrastructure, Property 10: Transforms Are Deterministic
@given(valid_ir_dataframe())
@settings(max_examples=100)
def test_identity_transform_is_deterministic(df: pl.DataFrame) -> None:
    """Test that identity transform produces consistent results.

    **Validates: Requirements 5.4, 17.1**

    Property: For any Transform and any valid IR DataFrame, applying the same
    transform multiple times to the same input should produce equivalent results.

    This test uses an identity transform as the simplest case.

    Args:
        df: Random valid IR DataFrame generated by Hypothesis
    """
    # Validate input
    validated_df = validate_ir(df)

    # Apply transform twice
    transform = IdentityTransform()
    result1 = transform.transform(validated_df)
    result2 = transform.transform(validated_df)

    # Results should be equal
    assert result1.equals(result2), (
        "Identity transform produced different results on same input. "
        "Transforms must be deterministic."
    )


# Feature: core-infrastructure, Property 10: Transforms Are Deterministic (Sort)
@given(valid_ir_dataframe())
@settings(max_examples=100)
def test_sort_transform_is_deterministic(df: pl.DataFrame) -> None:
    """Test that sort transform produces consistent results.

    **Validates: Requirements 5.4, 17.1**

    Property: For any Transform and any valid IR DataFrame, applying the same
    transform multiple times should produce equivalent results.

    This test uses a sort transform to verify determinism with data reordering.

    Args:
        df: Random valid IR DataFrame generated by Hypothesis
    """
    # Validate input
    validated_df = validate_ir(df)

    # Apply transform twice
    transform = SortTransform()
    result1 = transform.transform(validated_df)
    result2 = transform.transform(validated_df)

    # Results should be equal
    assert result1.equals(result2), (
        "Sort transform produced different results on same input. Transforms must be deterministic."
    )


# Feature: core-infrastructure, Property 10: Transforms Are Deterministic (Modification)
@given(valid_ir_dataframe())
@settings(max_examples=100)
def test_modification_transform_is_deterministic(df: pl.DataFrame) -> None:
    """Test that data modification transforms produce consistent results.

    **Validates: Requirements 5.4, 17.1**

    Property: For any Transform and any valid IR DataFrame, applying the same
    transform multiple times should produce equivalent results.

    This test uses a transform that modifies data (fills null descriptions)
    to verify determinism with data changes.

    Args:
        df: Random valid IR DataFrame generated by Hypothesis
    """
    # Validate input
    validated_df = validate_ir(df)

    # Apply transform twice
    transform = AddDescriptionTransform()
    result1 = transform.transform(validated_df)
    result2 = transform.transform(validated_df)

    # Results should be equal
    assert result1.equals(result2), (
        "Modification transform produced different results on same input. "
        "Transforms must be deterministic."
    )


# Feature: core-infrastructure, Property 10: Transforms Are Deterministic (Multiple Invocations)
@given(valid_ir_dataframe())
@settings(max_examples=100)
def test_transform_determinism_across_multiple_invocations(df: pl.DataFrame) -> None:
    """Test determinism across many invocations.

    **Validates: Requirements 5.4, 17.1, 17.2, 17.3**

    Property: For any Transform and any valid IR DataFrame, applying the same
    transform multiple times (more than 2) should produce equivalent results
    every time.

    This test verifies that determinism holds across many invocations, not just
    two consecutive calls.

    Args:
        df: Random valid IR DataFrame generated by Hypothesis
    """
    # Validate input
    validated_df = validate_ir(df)

    # Apply transform 5 times
    transform = IdentityTransform()
    results = [transform.transform(validated_df) for _ in range(5)]

    # All results should be equal to the first result
    first_result = results[0]
    for i, result in enumerate(results[1:], start=2):
        assert first_result.equals(result), (
            f"Transform invocation {i} produced different result than invocation 1. "
            f"Transforms must be deterministic across all invocations."
        )


# Feature: core-infrastructure, Property 10: Transform Determinism with Validation
@given(valid_ir_dataframe())
@settings(max_examples=100)
def test_transform_determinism_with_validation(df: pl.DataFrame) -> None:
    """Test that determinism holds even after validation.

    **Validates: Requirements 5.4, 17.1**

    Property: For any Transform and any valid IR DataFrame, applying the same
    transform multiple times should produce equivalent results, and those results
    should remain valid IR.

    This test combines determinism with validation to ensure both properties
    hold together.

    Args:
        df: Random valid IR DataFrame generated by Hypothesis
    """
    # Validate input
    validated_df = validate_ir(df)

    # Apply transform twice
    transform = IdentityTransform()
    result1 = transform.transform(validated_df)
    result2 = transform.transform(validated_df)

    # Validate both results
    validated_result1 = validate_ir(result1)
    validated_result2 = validate_ir(result2)

    # Results should be equal
    assert validated_result1.equals(validated_result2), (
        "Transform produced different validated results on same input. "
        "Transforms must be deterministic even after validation."
    )
